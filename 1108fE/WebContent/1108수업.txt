
** Web SQL 
=>브라우저(로컬)에 많은 양의 데이터를 저장하고자 할 때 사용하는 API
=>다른 API로는 IndexedDB와 Web Storage가 있는데 WebStorage는하나의 Map으로 구성되어 있어
서 용량은 상관이 없는데 많은 종류의 데이터를 저장하기가 어렵습니다. 
=>WebSQL은 관계형 데이터베이스를 사용하고 IndexedDB는 Key와 Value형태로 저장 
=> 최근에는 IndexedDB를 권장합니다. 

1.작업 순서 
 데이터베이스를 오픈 -> 트랜잭션 시작 -> SQL실행 -> 데이터베이스를 닫기 
=>브라우저나 스마트폰의 앱은 종료를 자주 하기 때문에 닫기를 하지 않아도 문제가 잘 발생하지 
않습니다. 
=>서버 만들때는 연결 객체 관리를 잘 해야 합니다. 

2. 데이터베이스 열기 
openDatabase(데이터베이스 이름, 버전, 사용자에게 보여질 이름, 데이터베이스 크기, 처리가 완료된 경우
호출될 메소드) 

3. 트랜잭션 시작 
=>2번에서 리턴받은 객체를 이용해서 transaction(변수){

})

=>넘어가는 변수가 트랜잭션 변수 입니다. 
=>넘어가는 변수를 이용해서 SQL을 실행 -executeSql(sql구문)
=>sql 구문은 mysql과 유사 
=>웹브라우저나 스마트 디바이스 운영체제에는 SQLite라는 데이터베이스가 설치되어 있습니다. 
SQLite의 SQL은 MySQL과 거의 유사 
=>스마트 디바이스 운영체제에서는 SQL대신에 사용할 수 있는 문법도 제공 

4. executeSql메소드 
executeSql(SQL구문,[매핑할 데이터 배열], function(트랜잭션, SQL실행결과){ })
=>매핑할 데이터 배열은 SQL구문을 만들 때 나중에 데이터를 설정하기 위해서 ?로 입력해 놓은 곳에
삽입할 데이터배열입니다. 



**WebWorker
=>자바스크립트코드를 백그라운드에서 실행하기 위한 기술 - 스레드 
=>백그라운드에서 동작하는 코드를 worker라고 합니다. 
이코드는 화면에 보여지는 내용과는 전혀 관계가 없습니다. 
=>WebWorker가 나오기 전까지는 하나의 웹페이지는 하나의 스레드로 동작 
ajax는 자바스크립트 코드를 실행하는 것이 아니고 비동기적으로 서버에게 데이터를 받아오는 기술 
ajax는 데이터를 받는 것은 되지만 현재 페이지에서 작업을 백그라운드로 수행시키지는 못해서 
다른 URL에서 작업을 처리한 후 결과를 가져오는 방식으로 스레드 유사하게 동작시켰습니다. 
=>자바스크립트로 오랜시간이 걸리는 작업을 직접 처리하게 되면 작업이 끝날때까지 UI를 사용할 수 
없는 상태가 됩니다. 

1.워커의 생성 
var 변수 = new Worker(워커로 동작할 자바스크립트 파일의 경로) 

2.워커를 동작 - 이벤트를 발생 
변수.postMessage(필요한 메시지) 
=>sendMessage:순서대로 처리 
=>postMessage:다른 작업이 없을 때 처리 

3.워커를 수행할 파일
message 이벤트가 왔을 때 워커로 동작할 코드를 작성 
onmessage = function(e){
      워커로 수행할 내용 
      //결과를 호출한 곳으로 전송 
      postMessage(메시지);
}

4.워커를 수행시킨 쪽에서 결과를 받기 위한 이벤트 처리 
변수의 message 이벤트를 처리 

5. 양쪽에서 전송하고자 하는 데이터는 event 객체의 data속성을 이용 

6.예전의 웹 프로그래밍에서는 대부분 클라이언트는 작업을 하지 않고 서버가 작업을 수행한 후 
그 결과를 클라이언트가 받아서 사용을 했습니다. 
네트워크에 연결이 되어 있을 때는 문제가 발생하지 않지만 네트워크에 연결이 되어있지 않으면 
아무것도 할 수 없습니다. 

이 문제를 해결하기 위해서 사용할 수 있었던 방법은 서버에 연결되어 있으면 서버에게 요청하고 
그렇지 않은 로컬에서 처리하면 되는데 이방법을 사용하면 로컬에서 처리를 하는 동안 다른 작업을 
수행하지 못함 - 자바스크립트에는 근본적으로 스레드를 만들 수 있는 방법이 없기 때문에  

7.워커 수행중에 에러가 발생하면 error 이벤트가 발생 
워커 수행 중에 종료시키고자 하는 경우에는 terminate()를 호출하면 됩니다. 
워커 파일에 다른 자바스크립트 파일의 내용을 포함시키고자 하는 경우에는 importScripts(파일 경로)
워커에서 UI를 변경할 수는 없습니다. 
대부분의 언어가 작업을 수행하는 스레드에서는 UI변경을 못하게 합니다. 
메인스레드에서만 화면 갱신을 가능하도록 하는것이 일반적이고 다른 스레드에서 화면을 갱신하고자 
할 때는 메인 스레드에게 메시지를 전송해서 메인 스레드에서 화면을 갱신하도록 해야 합니다.
 
** 그 이외 HTML5 API 
1.수학식을 표현하기 위한 마크업언어 - MathML : 현재는 firefox에서만 지원 

2.Application Cache: HTML 파일을 출력하기 위해 필요한 리소스들을 캐싱해서 빠르게 접근할 수 있도
록 해주는 API 

3.ajax 요청 객체의 데이터 설정이나 이벤트가 추가 

4.web Push: 서버에서 클라이언트의 요청없이 데이터를 전송하는 API 

5. Web Socket: 브라우저 간에 서버를 이용해서 소켓 통신을 가능하도록 해주는 API

ajax, webPush, WebSocket 은 반드시 서버가 있어야 합니다. 


**자바스크립트 라이브러리 
1.TypeScript: 기존 자바스크립트의 superset 으로 기존 자바스크립트의 한계를 극복하기 위해서 만들
어진 스크립트 
=>정적타입을 사용할 수 있고 클래스도 만들 수도 있습니다. 
=>angular.js에서 표준으로 채택 

2.ES6(ECMAScript6)
=>자바스크립트 엔진에 포함된 스크립트 표준 
=>자바스크립트를 의미한다고 해도 되는데 javascript는 버전이 없고 ES의 버전으로 자바스크립트 버전을
나타냅니다. 

3.VanilaJS
=>순수하게 자바스크립트 만으로 구현 
=>외부 라이브러리나 프레임워크를 사용하면 작성은 쉬워지지만 가독성을 떨어뜨리고 실행속도를 느리게
할 수 있기 때문에 순수한 자바스크립트 만으로 구현하는 것을 권장

4.jQuery
=>크로스 브라우징(여러 브라우저에서 동일한 콘텐츠를 사용)을 지원하기 위한 자바스크립트 라이브러리 
=> 많은 플러그인을 가지고 있어서 웹 화면 구현을 쉽게 해주는 라이브러리 
=>웹 디자인 기능사 시험에 jQuery를 사용해도 됩니다. 

5.bootstrap.js
=>반응형 웹(크기가 다른 브라우저 화면에서 동일한 콘텐츠를 사용)을 쉽게 구현하기 위해서 만들어진 
자바스크립트 라이브러리 
=>N-Screen(여러 디바이스에서 동일한 콘텐츠를 사용) 

6.angular(google), react(facebook), vue 
=>MVC패턴을 쉽게 구현하기 위한 라이브러리  

7.express.js 
=>자바스크립트를 이용해서 웹 서버를 만들때 사용할 수 있는 라이브러리 

8. node.js 
=>자바스크립트를 이용해서 애플리케이션 서버를 만들때 사용할 수 있는 라이브러리 



**jQuery
=>크로스 브라우징을 만들어진 클라이언트 사이드 자바스크립트 라이브러리
=>write less, no more

1. 특징
1)크로스 브라우징 지원 
2)오픈 소스 프로젝트 
3)다양한 선택자를 지원 
4)시각적 효과가 뛰어남 
5)ajax 구현이 쉬움 

2.공식 사이트
=>www.jquery.com

3.버전 구분
1)1.x버전 : IE8.0이하 브라우저까지 전부 지원
2)3.x버전: IE 8.0 이하 브라우저 지원하지 않음 

4.사용법 
1)다른 사이트의 CDN이나 jquery사이트의 링크를 직접 이용 
=>CDN(Content Delivery Network): 콘텐츠를 효율적으로 사용하기 위해서 전 세계 여러 곳에 
콘텐츠를 저장해두고 사용자가 접속한 가장 가까운 곳에서 콘텐츠를 받아서 사용할 수 있도록 만드는 
네트워크로 최근에 Content Distribution Network이라고도 함 

2)다운로드 받아서 프로젝트에 포함시켜서 사용 

3)자바스크립트 파일 중에서 파일명.min.js는 원본 자바스크립트 파일에서 엔터와 공백등을 제거해서 
파일의 용량을 줄인 버전으로 기능은 min.없는 것과 동일 

4)jquery를 사용하는 script 코드 전에 링크를 설정해야 합니다. 

5)특별한 경우가 아니라면 스크립트 코드를 다운로드 받아서 로컬에 위치 시킨 후 사용
  
5.jQuery시작 이벤트 처리 
jQuery(document).ready(function(){
     처음 수행될 내용;
});
=>위의 코드를 줄여서 $(function(){ })으로 대체 가능 
=>html문서를 처음부터 끝까지 읽고 메모리에 로드 시키기 전에 발생하는 이벤트 
window의 load이벤트보다 먼저 수행 

6.jquery에서 선택자 사용 
=>$('선택자') 의 형식으로 DOM 객체를 사용 

*: 전체 선택 
태그: 태그 선택 
.클래스이름: 클래스선택 
#아이디: id 선택 

선택자:가상선택자: 가상 선택자(hover, active 등) 를 선택 

선택자1 선택자2: 선택자1 안에 있는 선택자2 
선택자1>선택자2: 선택자1의 첫번째 자식의 형태로 존재하는 선택자2

선택자1,선택자2: 선택자1 과 선택자2 모두 

7.getter 와 setter 
1)val(): 입력된 내용을 가져오거나 설정할 때 사용
2)html() : 태그 안의 내용을 가져오거나 설정할 때 사용 - 태그가 적용됨 
3)text()  : 태그안의 내용을 가져오거나 설정할 때 사용 - 태그가 적용 안됨 



8.속성 사용 
선택자.attr(속성이름): 속성의 값을 가져오기 
선택자.attr(속성이름, 값): 속성에 값을 설정  

9.문서 구조 변경 
선택자1.after(선택자2): 선택자2를 선택자1 뒤에 배치 
선택자1.before(선택자2): 선택자 2를 선택자1 앞에 배치 

선택자1.appendTo(선택자2): 선택자1을 선택자2의 마지막 자식으로 추가 
선택자1.prependTo(선택자2): 선택자1을 선택자2의 첫번째 자식으로 추가 

10.css조작 
선택자.css(속성이름, 값)
=>높이와 너비 그리고 좌표는 height(), width() 그리고 position 메소드를 이용해서도 가능 

11.화면 전환 효과 
=>show(), hide(), toggle()
=>slideDown(), slideUp(), slideToggle()
=>fadeIn(), fadeOut(), fadeToggle()

=>적용은 선택자.효과(시간, function(){ })
시간과 애니메이션이 종료된 후 호출될 함수를 설정 
시간은 slow, fast 형태로 적용 

=>애니메이션은 화면을 변화시키는 작업이라서 오랜 시간이 걸립니다. 
오랜시간이 걸리는 작업이라서 모아서 한꺼번에 처리합니다. 
애니메이션 실행 함수 다음에 코드를 입력하면 이 코드가 애니메이션 후에 실행되는 것이 아니고
비동기적으로 수행됩니다. 



























 
